--------------------------------------------
Git Commands: git merge and git rebase
--------------------------------------------

1. Definition of git merge
---------------------------
The 'git merge' command is used to combine the changes from one branch into another.
When you merge two branches, Git creates a new "merge commit" that joins their histories together.
This command keeps the full history of both branches intact and shows clearly where they diverged
and later came together.

In simple terms, merging takes the contents of a source branch (for example, 'feature') and
integrates it into the target branch (for example, 'main') without altering the existing commits.

Command example:
    git checkout main
    git merge feature

Visual Example of Merge:

      A---B---C--------M   ← main
           \      /
            D----E       ← feature

Here:
- D and E are commits in the 'feature' branch
- M is the merge commit created in 'main' combining changes from feature

Advantages of merging:
- Keeps a complete history of all branches and merges.
- Safe for shared branches since it does not rewrite commit history.

Disadvantages of merging:
- Can lead to a cluttered commit history with many merge commits.
- The commit graph may become more complex.

Use Case:
Merging is best when working in collaborative environments where multiple developers contribute to the
same repository. It helps preserve context and makes it easier to track when branches were integrated.

Example Scenario:
The 'dev' branch contains new features that are now ready for production.
To bring all those features into 'main', you can use:
    git checkout main
    git merge dev
This adds a merge commit that records the integration of development work into the production branch.

--------------------------------------------
2. Definition of git rebase
----------------------------
The 'git rebase' command is used to move or reapply commits from one branch onto another base commit.
Instead of merging histories together, rebasing rewrites the commit history to make it appear as if
your work was created on top of the latest version of another branch.

Command example:
    git checkout feature
    git rebase main

Visual Example of Rebase:

Before rebase:

      A---B---C    ← main
           \
            D---E  ← feature

After rebase (feature rebased on main):

      A---B---C    ← main
                 \
                  D'---E'  ← feature

Here:
- D' and E' are copies of D and E replayed on top of main
- Commit history is linear and no merge commit is created

Advantages of rebasing:
- Produces a cleaner, linear commit history.
- Removes unnecessary merge commits, making the history easier to read.

Disadvantages of rebasing:
- Changes commit IDs (because it rewrites history).
- Should not be used on shared branches that others are working on.

Use Case:
Rebase is best when you want to keep your feature branch up-to-date with the latest changes from 'main'
before merging it, or when you want a clean, linear project history.

Example Scenario:
You created a 'feature' branch a few days ago from 'main'.
Meanwhile, other teammates added new commits to 'main'.
Before you merge your feature branch back, you want to include the latest updates.
You can do this with:
    git checkout feature
    git rebase main
Now your branch includes all the latest 'main' changes and looks as if your commits were made after them.

--------------------------------------------
3. Key Difference Between Merge and Rebase
--------------------------------------------
| Aspect              | git merge                           | git rebase                            |
|----------------------|-------------------------------------|----------------------------------------|
| Purpose              | Combines branch histories           | Moves commits to a new base            |
| Commit History       | Keeps full, branching history       | Creates a clean, linear history        |
| Commit IDs           | Stay the same                       | Are rewritten (new IDs)                |
| Merge Commit         | Usually creates a merge commit      | Does not create a merge commit         |
| Use Case             | Safe for shared branches            | Best for local feature branch cleanup  |

--------------------------------------------
Summary:
----------
- Use 'git merge' when you want to safely bring changes from one branch to another
  while preserving history.
- Use 'git rebase' when you want to maintain a clean, linear history and are working
  on your own local branch.

--------------------------------------------
Real Time scenario 
--------------------------------------------

# Git Rebase – Target Branch, Current Branch & Common Ancestor Rule

## Scenario

main branch:
A → B → C → D → H

feat branch:
A → B → C → E → F → G

Common ancestor (merge-base):
A → B → C

---

## Core Rule of `git rebase`

Git rebase always follows these steps:

1. Find the **common ancestor** (merge-base) of the current branch and the target branch.
2. Identify commits that are **unique to the current branch** (after the common ancestor).
3. **Rewrite and replay those commits** on top of the target branch.

Only commits from the **current branch** are rewritten.
Commits from the **target branch are never changed**.

---

## Example 1: Rebase `main` onto `feat`

Command:
git checkout main
git rebase feat

- Current branch: main
- Target branch: feat
- Common ancestor: A-B-C

Commits unique to main:
D → H

Result:
A → B → C → E → F → G → D' → H'

Explanation:
- D and H are rewritten (You can verify this after matching the hash id before and after rebasing. It will change for D and H)
- E, F, G remain unchanged
- A, B, C remain unchanged

---

## Example 2: Rebase `feat` onto `main`

Command:
git checkout feat
git rebase main

- Current branch: feat
- Target branch: main
- Common ancestor: A-B-C

Commits unique to feat:
E → F → G

Result:
A → B → C → D → H → E' → F' → G'

Explanation:
- E, F, G are rewritten
- D and H remain unchanged
- A, B, C remain unchanged

---

## Key Rules to Remember

- The **common ancestor** is the cut-off point.
- Commits before the ancestor are never touched.
- Commits after the ancestor on the **current branch** are rewritten.
- Commits on the **target branch** are preserved as-is.
- Rebase creates a **linear history** and **no merge commit**.

---

## One-Line Mental Model

git rebase X =  
"Take my commits (current branch) and put them on top of X (target branch)."

---

## Warning

Never rebase a branch that is already shared with others, because rebase rewrites commit history.

--------------------------------------------
End of Notes
--------------------------------------------

